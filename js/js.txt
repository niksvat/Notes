Introduction
---------------
- ECMA
ECMA 5  -> ECMA 6
var    |   let, const etc

ECMA 6 = Major upgrade around 2015-16

- <script src="/path" defer> vs <script src="/path" async>
  - defer: script will be downloaded in parallel to parsing HTML but executed after whole file is downloaded (HTML)
  - async: scripts will be downloaded and executed asap

- "use strict" 
- Event loop, stack, heap memory management 

Total 7 types of data type:
1. Number
2. string
3. boolean
4. null
5. undefined
6. Symbol (NaN is type of number, Infinity, -Infinity) (create symbol type var x = Symbol('This is test'))
7. Object

number + string = string (parseInt)

Function
----------------------------
- By default, function returns undefined.
- Function expression : hoisted and can't be called before the declaration.
  const x = function(){
  }
- Named function Declaration: : hoisted, can be called before the declaration.
 function hello(){
  }
- IIFE (Immediately invoked function expression)
  Example:
          (async () => {
              await main();
          })();

- factory function & clousre

let multiplier = 1.1;

function createTaxCalculator(tax) {
  function calculateTax(amount) {
    console.log(multiplier);
    return amount * tax * multiplier;
  }

  return calculateTax;
}

const calculateVatAmount = createTaxCalculator(0.19);
const calculateIncomeTaxAmount = createTaxCalculator(0.25);

// multiplier = 1.2;

console.log(calculateVatAmount(100));
console.log(calculateVatAmount(200));




var, let, const
----------------------------
- var has function scope
- let, const has block scope
- var is hoisted, let & const are not hoisted

if else
----------------------------
console.log(1 == 1);            => true 
console.log(1 == "1");          => true
console.log('1' == 1);          => true 
console.log(0 == false);        => true
console.log(0 == null);         => false
console.log(0 == undefined);    => false
console.log(null == undefined); => true 

=== -> strict equality

Falsy

  - false
  - undefined
  - null
  - 0
  - NaN
  - "" (i.e., the empty string)

Switch
---------------------


    switch (n) {
        case 2:
            console.log("A");
        case 3:
            console.log("B");
        case 4:
            console.log("C");
        case 5:
            console.log("D");
        default:
            console.log("E");
    }
    
    switch(4) => C,D,E so break in required.



loops
-------------------------------------

let a = ['a','b','c','d','e'];
for(let x in a){
  console.log(x);
}
// 0,1,2,3,4,5

for(let x of a){
  console.log(x);
}
// a,b,c,d,e

const arr = ['a', 'b', 'c', 'd'];

arr.forEach((value, index, array) => {
    console.log('index', index, 'has a value of', value,
    'which correlates to array[' + index + ']:', array[index]);
});


try-catch-finally
--------------------------------------
- return from 'catch' or 'try' then finally will execute always
- throw new Error('custom message');
- or 
  throw {message: "Something"}

Spread operator
---------------

const arr1 = [1, 2, 3]
const arr2 = [...arr1] // spread elements of arr1
Math.min(...arr2) => will give min element from arr

const obj = {
  info: 'something',
  name: 'something'
}

const obj2 = {...ojb} // new object with values copied from previous

Array and object restructuring:
-------------------------------

const [first, sec] = [1, 2, 3] //first -> 1

const obj = {

  info: 'something',
  name: 'something'

}
const {info} = obj; // info refers to obj's info





Object
--------------------------------------
- attributes and behaviour
- notations: object.propertyname or object['propertyname']
- creations:
  objects can be created via
    -Object initialzers  
      * Object.create()
      * 'new' keyworkd
      * Object literals
    - constructor function
      
************************************
var x = {
    a: 5, 
    foo: function() {
        return this.a * this.a;
    }
};

var o = Object.create(x);
************************************

var o = new Object();

o.a = 4;
o.b = 'Rome';
o.c = true;
************************************
//intiatilzer
var p = {
    a: 3, 
    b: 'Rome', 
    c: false
};
************************************
// constructor functions
function Actor(firstName, lastName, Age) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.Age = Age;
}

var a1 = new Actor('Julia', 'Roberts', 48);
var a2 = new Actor('Kate', 'Winslet', 40);
************************************

Internal property, getter and setters

_title => Psuedo private field, means its just convention but it can be accessed
#title => this is private property and can't be accessed. (new concept)

const obj = {
  set title(val) {
    this._title = val;   //triggered when obj.title = 'something';
  },
  get title() {
    return this._title; //triggered when console.log(obj.title);
  }
}

Object.assign
***************

const newObj = Object.assign({}, obj); //copy but not shallow

bind, call, apply (this)
******************

  function something() {
    console.log(this);
  }

bind
 - something.bind(object) // it won't execute function something

call
- something.call(object, , , , )

apply
- something.apply(object, [,,,])

this will now refers to object in something

this & arrow function
*********************

function() {
  console.log(this); //-> this refers to something that call this function
}

() => {
console.log(this) //->refers to this just outside of this arrow function 
}

Example 1:
const team = {
  name: "something",
  people: ["a", "b"],
  getname() {
    this.people.forEach(p => {
      console.log(p + " " + this.name); // this works
    });
  }
}

const team = {
  name: "something",
  people: ["a", "b"],
  getname() {
    this.people.forEach(function(p){
      console.log(p + " " + this.name);  // this.name is undefined since, this will refer to window object.
    });
  }
}

Example 2:

const person = { 
    name: 'Max',
    greet: () => {
        console.log(this.name); // however this refers to global object 'window' (even in strict mode)
    }
};
 
person.greet(); 

*************************************************** CLASSES ***************************************************
(https://www.hackerrank.com/challenges/js10-class/topics)

=> Using constructor functions
-------------------------------------
function Fruit (type) {
    this.type = type;
    this.color = 'unknown';
    this.getInformation = getFruitInformation;
}

function getFruitInformation() {
    return 'This ' + this.type + ' is ' + this.color + '.';
}

let lime = new Fruit('Mexican lime');
console.log(lime.getInformation());



=> Using internal functions defination
---------------------------------------
function Fruit (type) {
    this.type = type;
    this.color = 'unknown';
    this.getInformation = function() {
        return 'This ' + this.type + ' is ' + this.color + '.';
    }
}

let lime = new Fruit('Mexican lime');
console.log(lime.getInformation());

NOTE: Here function is created everytime we create new object

=> Prototype
---------------------------------------
- Every function in js has prototype property, which act as blueprint of object for this function. This is used in inheritance.


function Fruit (type) {
    this.type = type;
    this.color = 'unknown';
}

Fruit.prototype.getInformation = function(){
  return 'This ' + this.type + ' is ' + this.color + '.';
}

=> Using object literals
----------------------------------------
let x = {
  a: 1,
  b: function() {
         return 'aaaa';
     }
}

console.log(x.a);


=> Using class keyword (syntatic sugar)
--------------------------------------
- This is not hoisted while functions declarations are hoisted.

class Polygon {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
}

let p = new Polygon(1, 2);

    * Unnamed class
       let a =  class {
          constructor(par){
            this.par = par;
          }
       } 

    * Named class 
      let a = class polygon{
        //todo
      }

- constructor is only one special method, called once when object is created and use for intitalization
- To implement inheritance, super keyword is used, to call parent class constructor.

- Static methods (methods relevant to all object of classes)
---------------------------------------------------------------------

class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    static distance(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
}

const p1 = new Point(5, 5);

- Inheritance
-------------------------------------------------------------------
- inheritance is supported using extends keyword
- We can also extends functional classes
- child override parent function


class Animal {
    constructor(name) {
        this.animalType = 'Animal'
        this.name = name;
    }
    type() {
        console.log(this.name, 'is type', this.animalType);
    }
    speak() {
        console.log(this.name, 'speaks.');
    }
}

class Dog extends Animal {
    constructor(name, collarColor) {
        super(name);
        this.animalType = 'Dog';
        this.collarColor = collarColor;
    }
    speak() {
        console.log(this.name, 'barks.');
    }
    collar() {
        console.log(this.name, 'has a', this.collarColor, 'collar.');
    }
}

let spot = new Dog('Spot', 'red');
spot.type();   //spot is type of dog.
spot.speak();  //spot barks.
spot.collar(); //spot has red collar.


Prototype
--------
Each object has prototype and this is basically act as fallback object. There is prototype chain, and js use it to connect objects internally. (__proto__)
JS keep checking prototype to find method in chain




